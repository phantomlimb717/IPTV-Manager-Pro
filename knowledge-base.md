# IPTV Technical Knowledge Base

This document details technical findings regarding IPTV protocols, playlist management, and validation logic, as observed in the `iptv-api` codebase. It serves as a reference for building custom IPTV verification tools.

## 1. M3U/TXT Playlist Parsing

### M3U Format
The application identifies M3U playlists by the `#EXTM3U` tag. It uses regex to parse channel information.

*   **Standard M3U Pattern:**
    ```regex
    ^#EXTINF:-1[\s+,，](?P<attributes>[^,，]+)[，,](?P<name>.*?)\n(?P<value>.+)$
    ```
    *   **Components:**
        *   `attributes`: Often contains logo URLs (`tvg-logo`), group titles (`group-title`), or channel IDs (`tvg-id`).
        *   `name`: The display name of the channel.
        *   `value`: The stream URL.

*   **Multiline/Detailed M3U Pattern:**
    Handles VLC options (like headers) that might appear before the URL.
    ```regex
    ^#EXTINF:-1[\s+,，](?P<attributes>[^,，]+)[，,](?P<name>.*?)\n(?P<options>(#EXTVLCOPT:.*\n)*?)(?P<value>.+)$
    ```

### TXT Format
A simpler format often used in this ecosystem, formatted as `Name,URL`.

*   **Pattern:**
    ```regex
    ^(?P<name>[^,，]+)[,，](?!#genre#)(?P<value>.+)$
    ```

### Implementation Example (Parsing Logic)
The following Python snippet demonstrates how to parse a playlist content string using the regex patterns above.

```python
import re

def parse_m3u_content(content):
    """
    Parses M3U content and extracts channel information including VLC options.
    """
    # Regex for standard and multiline M3U entries
    multiline_m3u_pattern = re.compile(
        r"^#EXTINF:-1[\s+,，](?P<attributes>[^,，]+)[，,](?P<name>.*?)\n(?P<options>(#EXTVLCOPT:.*\n)*?)(?P<value>.+)$",
        re.MULTILINE
    )

    results = []
    for match in multiline_m3u_pattern.finditer(content):
        group_dict = match.groupdict()
        name = group_dict.get("name", "").strip()
        value = group_dict.get("value", "").strip()

        # Extract headers from VLC options
        options = group_dict.get("options", "")
        headers = {}
        if options:
            # key=value parsing for options
            for line in options.split('\n'):
                if 'http-user-agent' in line.lower():
                    headers['User-Agent'] = line.split('=')[1].strip()
                elif 'http-referer' in line.lower():
                    headers['Referer'] = line.split('=')[1].strip()

        if name and value:
            results.append({
                "name": name,
                "url": value,
                "headers": headers,
                "attributes": group_dict.get("attributes", "")
            })
    return results
```

## 2. Xtream Codes / Xstream

While this application does not natively interface with Xtream Codes API endpoints (e.g., `player_api.php` for account status), it consumes streams generated by them.

*   **URL Structure:**
    Xtream Codes panels typically export M3U playlists via a `get.php` endpoint:
    ```
    http://domain.com:port/get.php?username=USER&password=PASS&type=m3u&output=ts
    ```
*   **Verification Strategy:**
    To verify these credentials without a full player API client, you can:
    1.  **Request the M3U:** A valid credential will return a 200 OK and a playlist file. An invalid one often returns 401 Unauthorized or 404.
    2.  **Test a Stream:** Extract a single stream URL from the playlist and attempt a HEAD request or a short byte download.

## 3. Speed Testing & Validation Logic

The core value of this application is its robust verification logic.

### Connectivity & Speed Check (Python Implementation)
The following snippet demonstrates how to measure download speed using `aiohttp`.

```python
import time
import aiohttp

async def get_speed_with_download(url, headers=None, timeout=10):
    """
    Measures download speed by fetching a chunk of the stream.
    Returns speed in MB/s.
    """
    start_time = time.time()
    total_size = 0
    # Minimum bytes to consider a valid sample (e.g., 64KB)
    min_bytes = 64 * 1024

    try:
        async with aiohttp.ClientSession(headers=headers) as session:
            async with session.get(url, timeout=timeout) as response:
                if response.status != 200:
                    return 0

                async for chunk in response.content.iter_any():
                    total_size += len(chunk)
                    elapsed = time.time() - start_time

                    # Stop after accumulating enough data or time
                    if total_size >= min_bytes and elapsed > 1.0:
                        break

    except Exception:
        return 0

    duration = time.time() - start_time
    if duration <= 0: return 0

    # Speed in MB/s
    speed_mb_s = (total_size / 1024 / 1024) / duration
    return speed_mb_s
```

### FFmpeg Fallback Strategy
If direct HTTP download fails (e.g., due to complex stream protocols), use `ffmpeg` to verify the stream.

```python
import asyncio
import re

async def verify_stream_ffmpeg(url, timeout=5):
    """
    Uses FFmpeg to verify a stream is active and extract bitrate.
    """
    args = ["ffmpeg", "-t", str(timeout), "-i", url, "-f", "null", "-"]

    proc = await asyncio.create_subprocess_exec(
        *args, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
    )

    # Read stderr for stats
    try:
        _, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout+2)
        output = stderr.decode('utf-8', errors='ignore')

        # Look for bitrate in output
        # e.g., "bitrate= 2500.5kbits/s"
        if "bitrate=" in output:
             return True
    except asyncio.TimeoutError:
        proc.kill()

    return False
```

### Resolution Checking
Use `ffprobe` to determine video quality (SD vs HD vs 4K).
```bash
ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of json <url>
```

## 4. EPG (Electronic Program Guide) Handling

The application fetches EPG data, typically in XMLTV format.

*   **Parsing:** Uses `xml.etree.ElementTree`.
*   **Structure:**
    *   `<channel id="...">`: Maps an ID to a display name.
    *   `<programme channel="..." start="..." stop="...">`: Contains the schedule.
*   **Timezones:** Critical to parse offsets (e.g., `+0800`) correctly using `datetime.strptime` with `%z`.

## 5. Advanced Access & Circumvention

To reliably access streams that might be blocked or restricted, the application employs several techniques.

### Header Injection
Some streams check for a specific `User-Agent` or `Referer` to prevent hotlinking. The application extracts these from M3U options.

*   **Extraction:**
    Looks for `#EXTVLCOPT` tags or specific attribute keys in the M3U data.
    *   `http-user-agent` -> `User-Agent`
    *   `http-referer` -> `Referer`
    *   `http-origin` -> `Origin`

### Resilience Patterns
*   **Whitelisting:** A whitelist system overrides quality checks, ensuring specific URLs are always included even if they temporarily fail verification.
*   **Proxying:** Using IPv6 proxies or standard HTTP proxies when direct connection fails.

## 6. Aggregation & De-duplication

Efficiently merging thousands of channels requires a structured approach.

### Data Structure
Channels are organized in a nested dictionary structure:
```python
{
    "Category Name": {
        "Channel Name": [
            { "url": "...", "speed": 1.2, "resolution": "1920x1080", ... },
            { "url": "...", "speed": 0.5, ... }
        ]
    }
}
```

## 7. Failure Analysis & "Frozen" Logic

A robust checker must distinguish between a temporary glitch and a dead credential. The following logic implements an "Exponential Backoff" strategy.

### Recommended Failure Handling Strategy (Python Example)

```python
import time

# Dictionary to store state: { "url": { "bad_count": 0, "frozen_until": timestamp } }
credential_state = {}

MAX_BACKOFF = 24 * 3600  # 24 hours
BASE_BACKOFF = 60        # 1 minute

def mark_credential_bad(url):
    """
    Increases the penalty for a failing credential.
    """
    state = credential_state.setdefault(url, {"bad_count": 0, "frozen_until": 0})

    # Increment bad count
    state["bad_count"] += 1

    # Calculate backoff: 2^bad_count * 60 seconds
    backoff = min(MAX_BACKOFF, (2 ** state["bad_count"]) * BASE_BACKOFF)
    state["frozen_until"] = time.time() + backoff

    print(f"Credential {url} failed {state['bad_count']} times. Frozen for {backoff}s.")

def is_credential_frozen(url):
    """
    Checks if a credential is currently in the penalty box.
    """
    state = credential_state.get(url)
    if not state:
        return False

    if time.time() < state["frozen_until"]:
        return True

    return False

def mark_credential_good(url):
    """
    Resets the penalty for a working credential.
    """
    state = credential_state.get(url)
    if state:
        # Decrease bad count or reset entirely
        state["bad_count"] = max(0, state["bad_count"] - 1)
        state["frozen_until"] = 0
```

## 8. Geo-Location & ISP Metadata

To provide richer data about credentials, use a local IP database (like `qqwry.ipdb` or MaxMind GeoLite2) to avoid rate limits on public APIs.

*   **Workflow:**
    1.  **DNS Resolution:** Resolves the hostname to an IP.
    2.  **Lookup:** Queries the local DB for Country, Region, City, and ISP.
    3.  **Caching:** Cache Host->IP mappings to reduce DNS queries.

## Appendix: Xtream Codes Player API (External Research)

*Note: The primary `iptv-api` codebase focuses on stream checking. This section provides the missing standard API protocol details required to build a full Account/Credential Checker.*

### Standard Endpoint
The Xtream Codes API (and compatible panels like XUI) uses a standard PHP endpoint for authentication.

*   **URL:** `http://domain:port/player_api.php`
*   **Method:** `GET` or `POST`
*   **Parameters:**
    *   `username`: The account username.
    *   `password`: The account password.

### Response Structure (JSON)
A successful authentication returns a JSON object containing `user_info` and `server_info`.

```json
{
    "user_info": {
        "username": "user123",
        "password": "password123",
        "message": "Authentication Success",
        "auth": 1,
        "status": "Active",
        "exp_date": "1735689600",
        "is_trial": "0",
        "active_cons": "1",
        "created_at": "1672531200",
        "max_connections": "2",
        "allowed_output_formats": ["m3u8", "ts", "rtmp"]
    },
    "server_info": {
        "url": "domain.com",
        "port": "8080",
        "https_port": "8443",
        "server_protocol": "http",
        "rtmp_port": "8880",
        "timestamp_now": 1704067200,
        "time_now": "2024-01-01 00:00:00",
        "timezone": "Europe/London"
    }
}
```

### Critical Fields for Checking
*   **`user_info.auth`**: `1` means valid, `0` means invalid/banned.
*   **`user_info.status`**: Should be "Active".
*   **`user_info.exp_date`**: Unix timestamp of expiration. (Check if `exp_date < time.time()`).
*   **`user_info.active_cons`** vs **`user_info.max_connections`**: Use this to determine if the account is currently fully used.

### Python Implementation Example
```python
import requests

def check_xtream_account(base_url, username, password):
    api_url = f"{base_url.rstrip('/')}/player_api.php"
    params = {"username": username, "password": password}

    try:
        response = requests.get(api_url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        user_info = data.get("user_info", {})

        if user_info.get("auth") != 1:
            return {"status": "Invalid", "reason": "Auth failed"}

        return {
            "status": user_info.get("status"),
            "exp_date": user_info.get("exp_date"),
            "max_connections": user_info.get("max_connections"),
            "active_connections": user_info.get("active_cons")
        }

    except Exception as e:
        return {"status": "Error", "reason": str(e)}
```
